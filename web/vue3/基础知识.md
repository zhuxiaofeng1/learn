一、组件
每个vue应用都是通过createApp函数创建的，传递给createApp的选项用于配置根组件。当挂载应用时，该组件被用作渲染的起点。
一个应用需要被挂载到一个dom元素中。
eg:
const RootComponent = {...}
const app = Vue.createApp(RootComponent);
const vm = app.mount("#app");
注册一个全局组件：
const app = Vue.createApp({...})
app.component("custom-component", {
    ...
})
调用：<custom-component></custom-component>

二、计算属性
eg:
var vm = new Vue({
    el:"#app",
    data: {
        name: "A",
    },
    computed: {
        site: {
            get: function() {
                return this.name;
            },
            set: function(name) {
                this.name = name;
            }
        }
    }
})
三、事件修饰符

<!-- 阻止单击事件继续传播 -->
<a @click.stop="doThis"></a>

<!-- 提交事件不再重载页面 -->
<form @submit.prevent="onSubmit"></form>

<!-- 修饰符可以串联 -->
<a @click.stop.prevent="doThat"></a>

<!-- 只有修饰符 -->
<form @submit.prevent></form>

<!-- 添加事件监听器时使用事件捕获模式 -->
<!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 -->
<div @click.capture="doThis">...</div>

<!-- 只当在 event.target 是当前元素自身时触发处理函数 -->
<!-- 即事件不是从内部元素触发的 -->
<div @click.self="doThat">...</div>

四、侦听器
默认情况下，用户创建的侦听器回调，都会在 Vue 组件更新之前被调用。这意味着你在侦听器回调中访问的 DOM 将是被 Vue 更新之前的状态。

如果想在侦听器回调中能访问被 Vue 更新之后的DOM，你需要指明 flush: 'post' 选项：
export default {
  // ...
  watch: {
    key: {
      handler() {},
      flush: 'post'
    }
  }
}

也可以通过组件实例的$watch()来命令式地创建一个侦听器。
export default {
    created() {
        this.$watch("key", (newKey) = > {
            // ...
        })
    }
}
在少数情况下，需要在组件卸载之前停止一个侦听器，可以调用$watch() api返回函数：
const unwatch = this.$watch("key", callback);
//....

//...不需要时候停止
unwatch();
